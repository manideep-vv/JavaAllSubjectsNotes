1
00:00:07,330 --> 00:00:10,390
There's three major components
or subsystems to the HotSpot

2
00:00:10,390 --> 00:00:11,750
Java Virtual Machine.

3
00:00:11,750 --> 00:00:14,290
Those are the VM
runtime, an area that

4
00:00:14,290 --> 00:00:16,660
provides a runtime
environment for things that

5
00:00:16,660 --> 00:00:20,270
sit on top of the runtime
environment, a garbage

6
00:00:20,270 --> 00:00:22,500
collector, or a memory
manager, a thing that

7
00:00:22,500 --> 00:00:25,195
manages object allocation
and garbage collection,

8
00:00:25,195 --> 00:00:29,190
and a JIT compiler, a component
that takes Java bytecode

9
00:00:29,190 --> 00:00:31,680
and generates native
assembly instructions

10
00:00:31,680 --> 00:00:33,930
for the underlying platform.

11
00:00:33,930 --> 00:00:37,140
The VM runtime-- it has many
responsibilities, including

12
00:00:37,140 --> 00:00:41,160
command line option parsing, the
starting and stopping of a JVM,

13
00:00:41,160 --> 00:00:43,980
error handling, exception
handling, class loading,

14
00:00:43,980 --> 00:00:46,160
and the Java
bytecode interpreter.

15
00:00:46,160 --> 00:00:49,530
It also handles the Java native
interface, thread management,

16
00:00:49,530 --> 00:00:50,870
and synchronization.

17
00:00:50,870 --> 00:00:53,050
The command line
options that you specify

18
00:00:53,050 --> 00:00:54,435
are handled by the runtime.

19
00:00:54,435 --> 00:00:56,060
The good news is you
don't have to know

20
00:00:56,060 --> 00:00:59,650
a lot of the internal details
about the HotSpot VM runtime.

21
00:00:59,650 --> 00:01:02,080
From a performance
perspective, the understanding

22
00:01:02,080 --> 00:01:05,335
of what it does and that is
the component that manipulates

23
00:01:05,335 --> 00:01:08,580
the command line options,
exception handling, error

24
00:01:08,580 --> 00:01:12,240
handling, class loading, is
done through the VM Runtime.

25
00:01:12,240 --> 00:01:14,160
The garbage collector
or memory manager

26
00:01:14,160 --> 00:01:17,480
is responsible for object
allocation and reclamation,

27
00:01:17,480 --> 00:01:19,200
in other words,
garbage collection.

28
00:01:19,200 --> 00:01:20,960
Most commonly this
component is thought

29
00:01:20,960 --> 00:01:22,467
of as the garbage collector.

30
00:01:22,467 --> 00:01:24,550
The behavior and efficiency
of a garbage collector

31
00:01:24,550 --> 00:01:27,150
can heavily influenced the
performance and responsiveness

32
00:01:27,150 --> 00:01:28,680
of a Java application.

33
00:01:28,680 --> 00:01:31,170
As a result, choosing an
appropriate garbage collector

34
00:01:31,170 --> 00:01:34,690
and tuning it are usually the
most frequently taken actions

35
00:01:34,690 --> 00:01:36,790
to realize performance
improvements in a Java

36
00:01:36,790 --> 00:01:37,860
application.

37
00:01:37,860 --> 00:01:40,850
The HotSpot JVM has four
different garbage collectors.

38
00:01:40,850 --> 00:01:43,710
All four garbage collectors are
known as generational garbage

39
00:01:43,710 --> 00:01:44,310
collectors.

40
00:01:44,310 --> 00:01:46,100
I'll explain what a
generational garbage

41
00:01:46,100 --> 00:01:47,600
collector in just a moment.

42
00:01:47,600 --> 00:01:49,300
Two of the garbage
collectors are

43
00:01:49,300 --> 00:01:51,950
known as stop the world
type garbage collectors.

44
00:01:51,950 --> 00:01:54,680
The other two are a combination
of a stop the world garbage

45
00:01:54,680 --> 00:01:57,380
collector and a mostly
concurrent garbage collector.

46
00:01:57,380 --> 00:01:58,940
A stop the world
garbage collector

47
00:01:58,940 --> 00:02:01,400
is one that stops all
Java application threads

48
00:02:01,400 --> 00:02:03,940
while the garbage collector
is doing its work.

49
00:02:03,940 --> 00:02:05,590
A mostly concurrent
garbage collector

50
00:02:05,590 --> 00:02:08,840
is one that concurrently
excuse most of the time

51
00:02:08,840 --> 00:02:11,340
while the Java
application is running.

52
00:02:11,340 --> 00:02:14,530
Back to the generational garbage
collectors, most allocated

53
00:02:14,530 --> 00:02:16,870
objects are unreachable
or eligible to be

54
00:02:16,870 --> 00:02:18,290
reclaimed very quickly.

55
00:02:18,290 --> 00:02:20,210
And there exists
few objects that

56
00:02:20,210 --> 00:02:23,270
live for a longer period of
time than younger objects.

57
00:02:23,270 --> 00:02:25,550
As a result, a generational
garbage collector

58
00:02:25,550 --> 00:02:28,610
is one that partitions the Java
heap into two or more regions

59
00:02:28,610 --> 00:02:29,960
or generations.

60
00:02:29,960 --> 00:02:32,530
The most common form of a
generational garbage collector

61
00:02:32,530 --> 00:02:34,480
is one that has a
young generation

62
00:02:34,480 --> 00:02:35,680
and an old generation.

63
00:02:35,680 --> 00:02:38,540
The young generation is for
newly allocated objects.

64
00:02:38,540 --> 00:02:41,180
And the old generation is
for longer lived objects.

65
00:02:41,180 --> 00:02:44,190
The premise at work here is
that the longer an object lives,

66
00:02:44,190 --> 00:02:46,650
the JVM's memory manager
or garbage collector

67
00:02:46,650 --> 00:02:49,255
will eventually migrate an
object from young generation

68
00:02:49,255 --> 00:02:52,410
to old generation the
longer that object lives.

69
00:02:52,410 --> 00:02:55,030
In Java 6 and Java
7 HotSpot JVMs,

70
00:02:55,030 --> 00:02:57,710
there's a third generation
called permanent generation,

71
00:02:57,710 --> 00:03:00,430
which holds metadata such
as class data structures.

72
00:03:00,430 --> 00:03:02,340
But objects themselves
are not migrated

73
00:03:02,340 --> 00:03:04,505
to the permanent generation
from the old generation

74
00:03:04,505 --> 00:03:06,380
to permanent generation.

75
00:03:06,380 --> 00:03:08,400
Sometimes folks are
confused a little bit

76
00:03:08,400 --> 00:03:10,330
by the additional
permanent generation.

77
00:03:10,330 --> 00:03:11,860
The permanent
generation, again, is

78
00:03:11,860 --> 00:03:15,170
used to hold metadata and
class data structures,

79
00:03:15,170 --> 00:03:18,240
not Java object
waste, in the same way

80
00:03:18,240 --> 00:03:21,640
that young generation and old
generation handle Java objects.

81
00:03:21,640 --> 00:03:25,330
In Java 8 HotSpot JVMs,
permanent generation

82
00:03:25,330 --> 00:03:27,340
is eliminated in
favor of a space

83
00:03:27,340 --> 00:03:29,790
or a region referred
to as a metaspace.

84
00:03:29,790 --> 00:03:31,960
It generally holds
the same data as what

85
00:03:31,960 --> 00:03:34,000
was held in the
permanent generation.

86
00:03:34,000 --> 00:03:38,020
But it is managed differently
in Java HotSpot JVMs.

87
00:03:38,020 --> 00:03:40,320
A few more details on
the young generation

88
00:03:40,320 --> 00:03:42,500
and old generation and
permanent generation,

89
00:03:42,500 --> 00:03:44,710
along with how they fit
together are covered

90
00:03:44,710 --> 00:03:46,490
a little later in this lesson.

91
00:03:46,490 --> 00:03:49,630
For the choices of garbage
collectors in the HotSpot JVM,

92
00:03:49,630 --> 00:03:51,220
there's a serial
garbage collector,

93
00:03:51,220 --> 00:03:54,030
which is a single threaded
stop the world young generation

94
00:03:54,030 --> 00:03:57,390
collector, and a single threaded
stop the world old generation

95
00:03:57,390 --> 00:03:58,300
collector.

96
00:03:58,300 --> 00:04:00,470
It was HotSpot's first
garbage collector.

97
00:04:00,470 --> 00:04:02,390
It also tends to have
the smallest memory

98
00:04:02,390 --> 00:04:04,870
footprint of the HotSpot
garbage collectors.

99
00:04:04,870 --> 00:04:07,250
A second garbage collector
called the throughput garbage

100
00:04:07,250 --> 00:04:09,210
collector, otherwise
commonly known

101
00:04:09,210 --> 00:04:12,000
as the parallel collector,
is a multithreaded stop

102
00:04:12,000 --> 00:04:13,970
the world young
generation collector

103
00:04:13,970 --> 00:04:17,700
and either a single threaded or
a multithreaded stop the world

104
00:04:17,700 --> 00:04:19,300
old generation collector.

105
00:04:19,300 --> 00:04:21,910
In the most recent
Java HotSpot JVMs,

106
00:04:21,910 --> 00:04:24,340
the default collector for
what is called a server class

107
00:04:24,340 --> 00:04:27,850
machine is a multithreaded young
generation and old generation

108
00:04:27,850 --> 00:04:28,750
collector.

109
00:04:28,750 --> 00:04:30,550
A server class
machine is defined

110
00:04:30,550 --> 00:04:33,460
as a machine that has 2
gigabyte or more of RAM

111
00:04:33,460 --> 00:04:35,770
and has 2 or more
virtual processors.

112
00:04:35,770 --> 00:04:38,990
The one exception to this rule
is that on 32-bit Windows,

113
00:04:38,990 --> 00:04:41,970
the default collector is the
serial garbage collector.

114
00:04:41,970 --> 00:04:45,060
A third garbage collector called
a concurrent garbage collector,

115
00:04:45,060 --> 00:04:48,680
otherwise commonly known as
CMS, is a multithreaded stop

116
00:04:48,680 --> 00:04:51,480
the world young generation
collector, a mostly concurrent

117
00:04:51,480 --> 00:04:53,090
old generation collector.

118
00:04:53,090 --> 00:04:54,950
There are phases to
the old generation

119
00:04:54,950 --> 00:04:57,950
collector that run concurrently
with the application.

120
00:04:57,950 --> 00:05:00,720
And there are some phases of
it that are stop the world.

121
00:05:00,720 --> 00:05:02,460
A fourth garbage
collector called

122
00:05:02,460 --> 00:05:05,370
G1 is a relatively
new garbage collector.

123
00:05:05,370 --> 00:05:09,890
It was officially supported
as of Java HotSpot 7 Update 4.

124
00:05:09,890 --> 00:05:11,840
G1 is a region
base multithreaded

125
00:05:11,840 --> 00:05:13,920
stop the world young
generation collector

126
00:05:13,920 --> 00:05:16,400
and a combination of
a mostly concurrent

127
00:05:16,400 --> 00:05:19,280
and stop the world old
generation collector.

128
00:05:19,280 --> 00:05:22,120
The major difference
between G1 and CMS

129
00:05:22,120 --> 00:05:25,910
is that G1 compacts the old
generation without requiring

130
00:05:25,910 --> 00:05:28,000
a full GC event.

131
00:05:28,000 --> 00:05:31,180
The last component, the third
component, the JIT compiler,

132
00:05:31,180 --> 00:05:34,400
its responsibility is to turn
Java bytecode into native code

133
00:05:34,400 --> 00:05:35,920
for the underlying platform.

134
00:05:35,920 --> 00:05:39,670
The goal of course is to offer
improved execution performance.

135
00:05:39,670 --> 00:05:41,610
Huge application
performance improvements

136
00:05:41,610 --> 00:05:44,320
are realized as the
result of JIT compilation.

137
00:05:44,320 --> 00:05:47,810
There's a couple of JIT compiler
choices in a HotSpot JVM.

138
00:05:47,810 --> 00:05:50,430
One is the Client
JVM, which is designed

139
00:05:50,430 --> 00:05:52,500
for the rapid
application startup.

140
00:05:52,500 --> 00:05:56,320
Another is the Server JVM,
which is highly optimized,

141
00:05:56,320 --> 00:05:58,820
producing high performing
generated code.

142
00:05:58,820 --> 00:06:01,350
It pays a penalty for
application startup,

143
00:06:01,350 --> 00:06:04,730
but also realizes peak
application performance.

144
00:06:04,730 --> 00:06:08,140
A recent addition called Tiered
is the best of both Client

145
00:06:08,140 --> 00:06:08,700
and Server.

146
00:06:08,700 --> 00:06:12,430
So at application startup,
it behaves like a Client JVM

147
00:06:12,430 --> 00:06:14,830
and continues to
optimize until it

148
00:06:14,830 --> 00:06:18,040
reaches the same level
of generated code

149
00:06:18,040 --> 00:06:21,020
and optimizations as we would
see with the Server JVM.

150
00:06:21,020 --> 00:06:24,740
So TieredCompilation is
the default for Java 8.